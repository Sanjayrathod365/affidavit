'use client';

import React, { useEffect, useRef, useState, useCallback, useMemo } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { toast } from 'sonner';
import { useRouter } from 'next/navigation';
import SimpleCanvas, { A4_WIDTH, A4_HEIGHT } from './SimpleCanvas';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Slider } from "@/components/ui/slider";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { ChevronDown, ChevronUp, Download, Eye, Grid, Layers, Save, Trash, Upload, X, Plus, Copy, Palette } from "lucide-react";
import { ArrowUpIcon, ArrowDownIcon, CopyIcon, TrashIcon } from "lucide-react";

// Types
interface CanvasElement {
  id: string;
  type: 'text' | 'image' | 'placeholder' | 'line' | 'rectangle' | 'circle';
  data: any;
}

interface Placeholder {
  id: string;
  name: string;
  description?: string;
  defaultValue?: string;
  type: 'text' | 'date' | 'number' | 'boolean' | 'select';
  options?: string[];
}

interface FabricTemplateEditorProps {
  templateId?: string;
  initialName?: string;
  initialElements?: any[];
  initialPlaceholders?: Placeholder[];
}

// Common placeholders used in affidavits
const COMMON_PLACEHOLDERS: Placeholder[] = [
  { id: 'name', name: 'Full Name', type: 'text', description: 'Full name of the person making the affidavit' },
  { id: 'address', name: 'Address', type: 'text', description: 'Current address' },
  { id: 'city', name: 'City', type: 'text' },
  { id: 'state', name: 'State', type: 'text' },
  { id: 'zip', name: 'ZIP Code', type: 'text' },
  { id: 'date', name: 'Date', type: 'date', description: 'Date of affidavit' },
  { id: 'signature', name: 'Signature', type: 'text', description: 'Electronic signature' },
  { id: 'caseNumber', name: 'Case Number', type: 'text', description: 'Legal case number' },
  { id: 'courtName', name: 'Court Name', type: 'text' },
  { id: 'partyName', name: 'Party Name', type: 'text', description: 'Name of legal party' },
  { id: 'attorneyName', name: 'Attorney Name', type: 'text' },
  { id: 'phoneNumber', name: 'Phone Number', type: 'text' },
  { id: 'email', name: 'Email', type: 'text' },
  { id: 'declarationText', name: 'Declaration', type: 'text', description: 'Standard declaration text' },
];

// Simple range input slider to replace Radix UI Slider
const SimpleSlider = ({
  value,
  min,
  max,
  step,
  className,
  id,
  onChange
}: {
  value: number;
  min: number;
  max: number;
  step: number;
  className?: string;
  id?: string;
  onChange: (value: number) => void;
}) => {
  // Use a ref to track the last reported value to prevent duplicate events
  const lastValueRef = useRef(value);
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = parseFloat(e.target.value);
    // Only trigger onChange if the value actually changed
    if (newValue !== lastValueRef.current) {
      lastValueRef.current = newValue;
      onChange(newValue);
    }
  };
  
  // Update ref when prop changes
  useEffect(() => {
    lastValueRef.current = value;
  }, [value]);
  
  return (
    <input
      type="range"
      id={id}
      min={min}
      max={max}
      step={step}
      value={value}
      onChange={handleChange}
      className={`${className} w-full h-4 appearance-none bg-gray-200 rounded-md cursor-pointer`}
      style={{
        backgroundSize: `${((value - min) * 100) / (max - min)}% 100%`,
        backgroundImage: 'linear-gradient(#3b82f6, #3b82f6)'
      }}
    />
  );
};

// Simple toggle switch to replace Radix UI Switch
const SimpleToggle = ({
  checked,
  onCheckedChange,
  id,
  label
}: {
  checked: boolean;
  onCheckedChange: (checked: boolean) => void;
  id: string;
  label?: string;
}) => {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onCheckedChange(e.target.checked);
  };
  
  return (
    <div className="flex items-center space-x-2">
      <div className="relative inline-block w-10 h-5 rounded-full cursor-pointer">
        <input
          type="checkbox"
          id={id}
          checked={checked}
          onChange={handleChange}
          className="sr-only"
        />
        <span 
          className={`block w-10 h-5 rounded-full transition-colors duration-200 ease-in-out ${checked ? 'bg-primary' : 'bg-gray-200'}`}
        />
        <span 
          className={`absolute left-0.5 top-0.5 block w-4 h-4 rounded-full bg-white transition-transform duration-200 ease-in-out ${checked ? 'translate-x-5' : 'translate-x-0'}`}
        />
      </div>
      {label && <Label htmlFor={id}>{label}</Label>}
    </div>
  );
};

// Main component
export default function FabricTemplateEditor({
  templateId,
  initialName = '',
  initialElements = [],
  initialPlaceholders = []
}: FabricTemplateEditorProps) {
  const router = useRouter();
  const [name, setName] = useState(initialName);
  const [selectedElement, setSelectedElement] = useState<any>(null);
  const [zoomLevel, setZoomLevel] = useState(100);
  const [showGrid, setShowGrid] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [debugInfo, setDebugInfo] = useState<string[]>([]);
  const [useDirectRender, setUseDirectRender] = useState(false); // Toggle between rendering approaches
  const [activeTab, setActiveTab] = useState("elements"); // Add missing activeTab state
  const [showFallbackUI, setShowFallbackUI] = useState(false); // Add missing showFallbackUI state
  const [loading, setLoading] = useState(false); // Add missing loading state
  const [showConfirmDelete, setShowConfirmDelete] = useState(false); // Add missing confirmation dialog state
  const [elementToDelete, setElementToDelete] = useState<any>(null); // Add missing element to delete state
  const [placeholders, setPlaceholders] = useState<Placeholder[]>(COMMON_PLACEHOLDERS); // Add missing placeholders state
  
  // References
  const fabricCanvas = useRef<any>(null);
  const fabricLib = useRef<any>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const canvasContainerRef = useRef<HTMLDivElement>(null);
  const canvasInitializedRef = useRef<boolean>(false);
  
  // Functions to set fabric references
  const setFabricCanvas = (canvas: any) => {
    fabricCanvas.current = canvas;
  };
  
  const setFabricLib = (lib: any) => {
    fabricLib.current = lib;
  };

  // Add debug log with timestamp
  const addDebugLog = (message: string) => {
    setDebugInfo(prev => [`[${new Date().toLocaleTimeString()}] ${message}`, ...prev.slice(0, 99)]);
    console.log("[TemplateEditor]", message);
  };

  // Element manipulation functions
  const bringElementForward = () => {
    if (!fabricCanvas.current || !selectedElement) return;
    fabricCanvas.current.bringForward(selectedElement);
    safeRenderAll(fabricCanvas.current);
  };

  const sendElementBackward = () => {
    if (!fabricCanvas.current || !selectedElement) return;
    fabricCanvas.current.sendBackward(selectedElement);
    safeRenderAll(fabricCanvas.current);
  };

  const deleteSelectedElement = () => {
    if (!fabricCanvas.current || !selectedElement) return;
    fabricCanvas.current.remove(selectedElement);
    setSelectedElement(null);
    safeRenderAll(fabricCanvas.current);
  };

  const duplicateSelectedElement = () => {
    if (!fabricCanvas.current || !selectedElement || !fabricLib.current) return;
    
    selectedElement.clone((cloned: any) => {
      fabricCanvas.current.discardActiveObject();
      cloned.set({
        left: cloned.left + 20,
        top: cloned.top + 20,
        evented: true,
      });
      
      fabricCanvas.current.add(cloned);
      fabricCanvas.current.setActiveObject(cloned);
      safeRenderAll(fabricCanvas.current);
    });
  };

  // Handle zoom change
  const handleZoomChange = useCallback((value: number) => {
    if (!fabricCanvas.current) return;
    
    // Prevent unnecessary updates
    if (zoomLevel === value) return;
    
    try {
      // Update the canvas zoom directly
      const zoom = value / 100;
      fabricCanvas.current.setZoom(zoom);
      fabricCanvas.current.requestRenderAll();
      
      // Update the React state after canvas update
      setZoomLevel(value);
    } catch (err) {
      console.error("Error changing zoom:", err);
      addDebugLog(`Zoom error: ${err.message}`);
    }
  }, [zoomLevel, fabricCanvas, addDebugLog]);

  // Handle object selection
  const handleObjectSelected = (e: any) => {
    if (e.selected && e.selected.length > 0) {
      setSelectedElement(e.selected[0]);
      addDebugLog(`Selected element: ${e.selected[0].type}`);
    } else {
      setSelectedElement(null);
    }
  };

  const handleCanvasReady = (canvas: any, fabric: any) => {
    addDebugLog("handleCanvasReady called");
    // Prevent multiple initializations
    if (canvasInitializedRef.current) {
      addDebugLog("Canvas already initialized - ignoring duplicate ready event");
      return;
    }
    
    if (!canvas || !fabric) {
      addDebugLog("Invalid canvas or fabric instance received");
      setError("Canvas initialization failed: Invalid parameters");
      setShowFallbackUI(true);
      return;
    }
    
    addDebugLog("Setting canvas and fabric references");
    
    // Patch event handlers to be more robust
    const originalOn = canvas.on;
    canvas.on = function(eventName: string, handler: Function) {
      try {
        return originalOn.call(this, eventName, (...args: any[]) => {
          try {
            return handler(...args);
          } catch (err) {
            console.error(`Error in event handler for ${eventName}:`, err);
            addDebugLog(`Event handler error: ${err.message}`);
            return undefined;
          }
        });
      } catch (err) {
        console.error(`Error setting up event listener for ${eventName}:`, err);
        addDebugLog(`Event setup error: ${err.message}`);
        return this;
      }
    };
    
    setFabricCanvas(canvas);
    setFabricLib(fabric);
    setLoading(false);
    
    try {
      // Set initialized flag before any operations that might cause re-renders
      canvasInitializedRef.current = true;
      
      // Validate the fabric instance
      if (!fabric || typeof fabric.Text !== 'function') {
        throw new Error("Invalid fabric instance - Text constructor not available");
      }
      
      // Check if canvas is valid
      if (!isCanvasValid(canvas)) {
        throw new Error("Canvas context is not available");
      }
      
      // Setup event listeners with error handling
      try {
        canvas.on('selection:created', handleObjectSelected);
        canvas.on('selection:updated', handleObjectSelected);
        canvas.on('selection:cleared', () => setSelectedElement(null));
        
        // Add a custom handler for context lost
        canvas.on('contextlost', () => {
          addDebugLog("Canvas context lost");
          setError("Canvas rendering context was lost. Please try again.");
        });
      } catch (eventErr) {
        addDebugLog(`Error setting up event listeners: ${eventErr.message}`);
      }
      
      // Load existing elements if available
      if (initialElements && initialElements.length > 0 && Array.isArray(initialElements)) {
        try {
          addDebugLog("Loading initial elements");
          // If initialElements is a JSON string, parse it
          if (typeof initialElements === 'string') {
            try {
              canvas.loadFromJSON(initialElements, () => {
                addDebugLog("JSON elements loaded");
                safeRenderAll(canvas);
              });
            } catch (parseErr) {
              addDebugLog(`Error parsing JSON elements: ${parseErr.message}`);
            }
          } 
          // If it's already a JSON object
          else if (typeof initialElements === 'object') {
            try {
              canvas.loadFromJSON(initialElements, () => {
                addDebugLog("Object elements loaded");
                safeRenderAll(canvas);
              });
            } catch (loadErr) {
              addDebugLog(`Error loading object elements: ${loadErr.message}`);
            }
          }
          addDebugLog("Initial elements loading completed");
        } catch (loadErr: any) {
          addDebugLog(`Error loading elements: ${loadErr.message}`);
          console.error("Error loading initial elements:", loadErr);
        }
      } else {
        // Add welcome text if no elements
        addDebugLog("Creating welcome text");
        try {
          const welcomeText = new fabric.Text('Welcome to Template Editor', {
            left: 50,
            top: 50,
            fontFamily: 'Arial',
            fontSize: 24,
            fill: '#333333'
          });
          
          // Add placeholder instructions
          const instructionText = new fabric.Text('Add elements from the panel on the right →', {
            left: 50,
            top: 100,
            fontFamily: 'Arial',
            fontSize: 16,
            fill: '#666666'
          });
          
          canvas.add(welcomeText);
          canvas.add(instructionText);
          addDebugLog("Welcome text added");
        } catch (textErr) {
          addDebugLog(`Error adding welcome text: ${textErr.message}`);
        }
      }
      
      // Render the canvas
      try {
        safeRenderAll(canvas);
        addDebugLog("Canvas rendering completed");
      } catch (renderErr) {
        addDebugLog(`Error rendering canvas: ${renderErr.message}`);
      }
      
      addDebugLog("Canvas initialization completed successfully");
      
      // Show toast after a slight delay to prevent render cycle issues
      setTimeout(() => {
        toast.success("Canvas initialized successfully!");
      }, 100);
    } catch (err: any) {
      addDebugLog(`Error: ${err.message}`);
      console.error("Error adding elements to canvas:", err);
      setError(`Canvas initialization succeeded but error adding elements: ${err.message}`);
      setShowFallbackUI(true);
    }
  };

  // Debug effect to check when component is unmounting
  useEffect(() => {
    addDebugLog("Template editor component mounted");
    return () => {
      addDebugLog("Template editor component unmounting");
    };
  }, []);

  const handleCanvasError = (err: Error) => {
    console.error("Canvas error:", err);
    addDebugLog(`Canvas error: ${err.message}`);
    setError(err.message);
    setShowFallbackUI(true);
  };

  const handleSaveTemplate = async () => {
    try {
      if (!name) {
        toast.error("Please enter a template name");
        return;
      }
      
      if (!fabricCanvas.current) {
        toast.error("Canvas is not ready");
        return;
      }
      
      // Check if canvas is valid
      if (!isCanvasValid(fabricCanvas.current)) {
        toast.error("Canvas context is not available");
        return;
      }
      
      // Show saving toast
      const saveToast = toast.loading("Saving template...");
      
      // Convert canvas to JSON
      const canvasJSON = fabricCanvas.current.toJSON(['data']);
      
      // Extract placeholders from canvas elements
      const usedPlaceholders = extractPlaceholdersFromCanvas();
      
      // Determine if we need to create or update
      const method = templateId ? 'PUT' : 'POST';
      const endpoint = templateId 
        ? `/api/affidavit-templates/${templateId}` 
        : `/api/affidavit-templates`;
        
      // API call - Make sure your API route supports the proper methods
      const response = await fetch(endpoint, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name,
          elements: canvasJSON,
          placeholders: usedPlaceholders,
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Failed to save template: ${response.statusText}`);
      }
      
      // Success toast
      toast.success(`Template ${templateId ? 'updated' : 'created'} successfully!`, {
        id: saveToast
      });
      
      // Navigate after a brief delay to ensure toast is visible
      setTimeout(() => {
        router.push('/affidavit-templates');
      }, 1000);
    } catch (err: any) {
      console.error("Error saving template:", err);
      toast.error(err.message);
    }
  };
  
  // Extract placeholders from canvas objects
  const extractPlaceholdersFromCanvas = () => {
    if (!fabricCanvas.current) return [];
    
    const usedPlaceholders: Placeholder[] = [];
    const placeholderIds = new Set<string>();
    
    // Iterate through all canvas objects
    fabricCanvas.current.getObjects().forEach((obj: any) => {
      if (obj.data && obj.data.isPlaceholder && obj.data.placeholderId) {
        if (!placeholderIds.has(obj.data.placeholderId)) {
          placeholderIds.add(obj.data.placeholderId);
          
          // Find the placeholder definition
          const placeholderDef = placeholders.find(p => p.id === obj.data.placeholderId);
          if (placeholderDef) {
            usedPlaceholders.push(placeholderDef);
          }
        }
      }
    });
    
    return usedPlaceholders;
  };
  
  // Export template as PDF
  const handleExportAsPDF = () => {
    if (!fabricCanvas.current) {
      toast.error("Canvas is not ready");
      return;
    }
    
    toast.info("Exporting as PDF - this feature will be implemented soon");
    
    // Real implementation would use a library like jspdf or handle this server-side
  };
  
  // Export template as PNG
  const handleExportAsPNG = () => {
    if (!fabricCanvas.current) {
      toast.error("Canvas is not ready");
      return;
    }
    
    try {
      // Convert canvas to dataURL
      const dataURL = fabricCanvas.current.toDataURL({
        format: 'png',
        quality: 1.0
      });
      
      // Create download link
      const link = document.createElement('a');
      link.download = `${name || 'template'}.png`;
      link.href = dataURL;
      link.click();
      
      toast.success("Template exported as PNG");
    } catch (err: any) {
      console.error("Error exporting as PNG:", err);
      toast.error(err.message);
    }
  };

  // Add placeholder to template
  const addPlaceholderToCanvas = (placeholder: Placeholder) => {
    if (!fabricCanvas.current || !fabricLib.current) {
      toast.error("Canvas is not ready");
      return;
    }
    
    try {
      // Check if canvas is valid before using it
      if (!isCanvasValid(fabricCanvas.current)) {
        toast.error("Canvas context is not available");
        return;
      }
      
      // Clear any existing selection
      fabricCanvas.current.discardActiveObject();
      
      // Create placeholder with enhanced visibility
      const placeholderText = new fabricLib.current.Textbox(`{{${placeholder.name}}}`, {
        left: 50 + Math.random() * 150,
        top: 50 + Math.random() * 150,
        width: 200,
        fontFamily: 'Arial',
        fontSize: 18,
        fontWeight: 'bold',
        fill: '#0066cc',
        backgroundColor: '#e6f7ff',
        padding: 8,
        borderColor: '#0066cc',
        strokeWidth: 1,
        stroke: '#0066cc',
        selectable: true,
        evented: true,
        visible: true,
        opacity: 1,
        data: {
          isPlaceholder: true,
          placeholderId: placeholder.id,
          placeholderType: placeholder.type
        }
      });
      
      // Add the placeholder
      fabricCanvas.current.add(placeholderText);
      
      // Make it the active object
      fabricCanvas.current.setActiveObject(placeholderText);
      
      // Force multiple renders to ensure visibility
      safeRenderAll(fabricCanvas.current);
      
      // Add a second render after a short delay
      setTimeout(() => {
        if (fabricCanvas.current) {
          safeRenderAll(fabricCanvas.current);
        }
      }, 100);
      
      // Show success message
      toast.success(`Added ${placeholder.name} placeholder`);
    } catch (err: any) {
      console.error("Error adding placeholder:", err);
      toast.error(`Failed to add placeholder: ${err.message}`);
    }
  };

  // Improved canvas validation
  const isCanvasValid = (canvas: any): boolean => {
    if (!canvas) return false;
    
    try {
      // Check if the canvas element and context exist
      return canvas.getContext() !== null && canvas.contextContainer !== null;
    } catch (e) {
      return false;
    }
  };
  
  // Debug function - add more detailed logs about objects
  const logCanvasObjects = (canvas: any) => {
    if (!canvas || !canvas.getObjects) return;
    
    try {
      const objects = canvas.getObjects();
      addDebugLog(`Canvas has ${objects.length} objects`);
      
      // Log details of each object
      objects.forEach((obj: any, index: number) => {
        addDebugLog(`Object ${index}: ${obj.type} - visible: ${obj.visible}, opacity: ${obj.opacity}, width: ${obj.width}, height: ${obj.height}, left: ${obj.left}, top: ${obj.top}`);
      });
      
      // Try to check if canvas is actually rendering
      if (canvas.lowerCanvasEl) {
        const ctx = canvas.lowerCanvasEl.getContext('2d');
        if (ctx) {
          // Get a few pixel samples to see if anything's drawn
          try {
            const midX = canvas.width / 2;
            const midY = canvas.height / 2;
            const sample = ctx.getImageData(midX, midY, 1, 1);
            const hasContent = !(sample.data[0] === 255 && sample.data[1] === 255 && sample.data[2] === 255);
            addDebugLog(`Canvas content check: ${hasContent ? 'HAS CONTENT' : 'APPEARS EMPTY'}`);
          } catch (err) {
            addDebugLog(`Error checking canvas pixels: ${err}`);
          }
        } else {
          addDebugLog('Canvas context is not available');
        }
      }
    } catch (err) {
      addDebugLog(`Error logging objects: ${err}`);
    }
  };

  // Safely render the canvas with more detailed error handling
  const safeRenderAll = (canvas: any) => {
    if (!canvas) return;
    
    try {
      addDebugLog('Attempting to render canvas');
      
      if (isCanvasValid(canvas)) {
        // Use requestRenderAll instead of renderAll for better performance
        if (typeof canvas.requestRenderAll === 'function') {
          canvas.requestRenderAll();
          addDebugLog('Canvas requestRenderAll called');
        } else if (typeof canvas.renderAll === 'function') {
          canvas.renderAll();
          addDebugLog('Canvas renderAll called');
        } else {
          addDebugLog('No render method available');
        }
        
        // Force a second render after a brief delay to ensure visibility
        setTimeout(() => {
          try {
            if (isCanvasValid(canvas)) {
              if (typeof canvas.requestRenderAll === 'function') {
                canvas.requestRenderAll();
              } else if (typeof canvas.renderAll === 'function') {
                canvas.renderAll();
              }
              addDebugLog('Delayed render completed');
              
              // Log object count after render
              try {
                const objCount = canvas.getObjects().length;
                addDebugLog(`Objects after render: ${objCount}`);
              } catch (err) {
                addDebugLog(`Error counting objects: ${err}`);
              }
            }
          } catch (err) {
            addDebugLog(`Error in delayed render: ${err}`);
          }
        }, 100);
      } else {
        addDebugLog('Canvas is not valid for rendering');
      }
    } catch (err) {
      addDebugLog(`Error in safeRenderAll: ${err}`);
    }
  };

  // Handle adding a text element to the canvas
  const handleAddText = () => {
    if (!fabricCanvas.current || !fabricLib.current) {
      toast.error("Canvas is not ready");
      return;
    }
    
    try {
      addDebugLog('Creating text element');
      
      // Add text element with enhanced visibility properties
      const text = new fabricLib.current.Textbox('New Text', {
        left: 50 + Math.random() * 200,
        top: 50 + Math.random() * 200,
        width: 200,
        fontSize: 20,
        fill: '#000000',
        fontFamily: 'Arial',
        borderColor: '#ff0000',
        cornerColor: '#00ff00',
        cornerSize: 12,
        transparentCorners: false,
        paintFirst: 'fill',
        visible: true,
        opacity: 1
      });
      
      addDebugLog(`Text created: ${text.text} at (${text.left},${text.top})`);
      
      // Ensure object is set to be visible
      text.set({
        visible: true,
        opacity: 1,
        selectable: true,
        evented: true
      });
      
      fabricCanvas.current.discardActiveObject();
      fabricCanvas.current.add(text);
      fabricCanvas.current.setActiveObject(text);
      
      // Log canvas status
      const objCount = fabricCanvas.current.getObjects().length;
      addDebugLog(`Canvas now has ${objCount} objects`);
      
      addDebugLog('Running safeRenderAll');
      safeRenderAll(fabricCanvas.current);
      
      // Add a delayed check to verify the object was added
      setTimeout(() => {
        try {
          logCanvasObjects(fabricCanvas.current);
        } catch (err) {
          addDebugLog(`Error in delayed check: ${err}`);
        }
      }, 300);
      
      addDebugLog('[TemplateEditor] Added text element');
    } catch (err) {
      addDebugLog(`Error adding text: ${err}`);
      toast.error(`Failed to add text: ${err}`);
    }
  };

  // Handle adding a rectangle element to the canvas
  const handleAddRectangle = () => {
    if (!fabricCanvas.current || !fabricLib.current) {
      toast.error("Canvas is not ready");
      return;
    }
    
    try {
      addDebugLog('Creating rectangle element');
      
      // Create rectangle with highly visible properties
      const rect = new fabricLib.current.Rect({
        left: 50 + Math.random() * 200,
        top: 50 + Math.random() * 200,
        width: 100,
        height: 100,
        fill: '#4287f5',
        stroke: '#000000',
        strokeWidth: 2,
        rx: 0,
        ry: 0,
        visible: true,
        opacity: 1,
        paintFirst: 'fill',
        borderColor: '#ff0000',
        cornerColor: '#00ff00',
        cornerSize: 12,
        transparentCorners: false
      });
      
      addDebugLog(`Rectangle created at (${rect.left},${rect.top})`);
      
      // Ensure object is set to be visible
      rect.set({
        visible: true,
        opacity: 1,
        selectable: true,
        evented: true
      });
      
      fabricCanvas.current.discardActiveObject();
      fabricCanvas.current.add(rect);
      fabricCanvas.current.setActiveObject(rect);
      
      // Log canvas status
      const objCount = fabricCanvas.current.getObjects().length;
      addDebugLog(`Canvas now has ${objCount} objects`);
      
      addDebugLog('Running safeRenderAll');
      safeRenderAll(fabricCanvas.current);
      
      // Add a delayed check
      setTimeout(() => {
        try {
          logCanvasObjects(fabricCanvas.current);
        } catch (err) {
          addDebugLog(`Error in delayed check: ${err}`);
        }
      }, 300);
      
      addDebugLog('[TemplateEditor] Added rectangle element');
    } catch (err) {
      addDebugLog(`Error adding rectangle: ${err}`);
      toast.error(`Failed to add rectangle: ${err}`);
    }
  };

  // Create a new custom placeholder
  const createCustomPlaceholder = (name: string, type: string = 'text') => {
    if (!name) return;
    
    const newPlaceholder: Placeholder = {
      id: `custom_${uuidv4()}`,
      name,
      type: type as any,
      description: 'Custom placeholder'
    };
    
    setPlaceholders(prev => [...prev, newPlaceholder]);
    addPlaceholderToCanvas(newPlaceholder);
  };

  // Update properties of selected element
  const updateSelectedElementProperty = useCallback((property: string, value: any) => {
    if (!fabricCanvas.current || !selectedElement) return;
    
    // Check if the value is actually different to prevent update loops
    if (selectedElement[property] === value) return;
    
    // Update directly on the object without triggering a React state update
    try {
      selectedElement.set(property, value);
      
      // Only render the canvas, don't update React state here
      if (fabricCanvas.current) {
        fabricCanvas.current.requestRenderAll();
      }
    } catch (err) {
      console.error(`Error updating property ${property}:`, err);
      addDebugLog(`Property update error: ${err.message}`);
    }
  }, [selectedElement, fabricCanvas, addDebugLog]);

  // Setup global error handler for fabric.js errors
  useEffect(() => {
    const handleError = (event: ErrorEvent) => {
      // Only capture fabric.js errors
      if (event.message && event.message.includes('fabric.js')) {
        console.error('Fabric.js error caught:', event.message);
        event.preventDefault(); // Prevent default error handling
        addDebugLog(`Fabric.js error: ${event.message}`);
      }
    };
    
    // Add global error handler
    window.addEventListener('error', handleError);
    
    return () => {
      window.removeEventListener('error', handleError);
    };
  }, []);

  // Fallback UI if fabric.js fails to initialize properly
  if (error) {
    return (
      <div className="container mx-auto p-4">
        <div className="bg-yellow-50 border border-yellow-200 p-4 rounded-md mb-4">
          <h2 className="text-lg font-semibold text-yellow-800 mb-2">Canvas Initialization Error</h2>
          <p className="text-yellow-700">{error}</p>
          <div className="mt-4 flex space-x-3">
            <Button onClick={() => window.location.reload()}>
              Reload Page
            </Button>
            <Button variant="outline" onClick={() => router.push('/affidavit-templates')}>
              Back to Templates
            </Button>
          </div>
        </div>
        <div className="p-8 border rounded-md bg-gray-50 flex items-center justify-center">
          <div className="text-center">
            <p className="text-lg text-gray-500 mb-4">Unable to initialize template editor.</p>
            <p className="text-gray-400">Try refreshing the page or using a different browser.</p>
          </div>
        </div>
      </div>
    );
  }

  useEffect(() => {
    // Add additional check to force refresh the canvas periodically
    if (fabricCanvas.current) {
      const refreshInterval = setInterval(() => {
        try {
          // Check if there are objects on the canvas
          const objects = fabricCanvas.current.getObjects();
          addDebugLog(`Refresh check: Canvas has ${objects.length} objects`);
          
          // Force render to ensure they're visible
          safeRenderAll(fabricCanvas.current);
        } catch (err) {
          console.error("Error in refresh interval:", err);
        }
      }, 3000); // Check every 3 seconds
      
      return () => {
        clearInterval(refreshInterval);
      };
    }
  }, [fabricCanvas]);

  // Direct canvas initialization (alternative approach)
  const initializeDirectCanvas = async () => {
    try {
      if (!canvasRef.current || !canvasContainerRef.current) {
        addDebugLog("Direct canvas: Missing refs");
        return;
      }
      
      addDebugLog("Direct canvas: Starting initialization");
      
      // Import Fabric.js
      const fabricModule = await import('fabric');
      const fabric = fabricModule.fabric || fabricModule.default;
      fabricLib.current = fabric;
      
      addDebugLog(`Direct canvas: Fabric.js ${fabric.version} loaded`);
      
      // Clean up any existing canvas
      if (fabricCanvas.current) {
        addDebugLog("Direct canvas: Disposing existing canvas");
        try {
          fabricCanvas.current.dispose();
          fabricCanvas.current = null;
        } catch (err) {
          addDebugLog(`Direct canvas: Error disposing: ${err}`);
        }
      }
      
      // Clear canvas container
      while (canvasContainerRef.current.childNodes.length > 1) {
        canvasContainerRef.current.removeChild(canvasContainerRef.current.lastChild!);
      }
      
      // Set canvas dimensions
      canvasRef.current.width = A4_WIDTH;
      canvasRef.current.height = A4_HEIGHT;
      
      addDebugLog("Direct canvas: Creating new Fabric canvas");
      
      // Create new Fabric canvas
      const canvas = new fabric.Canvas(canvasRef.current, {
        width: A4_WIDTH,
        height: A4_HEIGHT,
        backgroundColor: '#ffffff',
        preserveObjectStacking: true,
        renderOnAddRemove: true,
        selection: true,
        enableRetinaScaling: false,
        objectCaching: false
      });
      
      // Store reference
      fabricCanvas.current = canvas;
      
      // Configure canvas
      canvas.setDimensions({
        width: A4_WIDTH,
        height: A4_HEIGHT
      });
      
      // Add zoom handling
      const updateZoom = (zoom: number) => {
        const container = canvasContainerRef.current;
        if (!container) return;
        
        const scale = zoom / 100;
        container.style.transform = `scale(${scale})`;
        container.style.transformOrigin = 'top left';
      };
      
      updateZoom(zoomLevel);
      
      // Add welcome text
      addDebugLog("Direct canvas: Creating welcome text");
      
      try {
        const welcomeText = new fabric.Text("Welcome to the Template Editor", {
          left: 100,
          top: 100,
          fontSize: 24,
          fill: '#000000',
          fontFamily: 'Arial'
        });
        
        canvas.add(welcomeText);
        canvas.renderAll();
        
        addDebugLog("Direct canvas: Welcome text added");
      } catch (err) {
        addDebugLog(`Direct canvas: Error adding welcome text: ${err}`);
      }
      
      addDebugLog("Direct canvas: Initialization completed");
      
      // Let the rest of the component know the canvas is ready
      handleCanvasReady(canvas, fabric);
      
    } catch (err: any) {
      addDebugLog(`Direct canvas: Initialization error: ${err.message}`);
      setError(err.message);
    }
  };

  // Handle changes to useDirectRender
  useEffect(() => {
    if (useDirectRender) {
      addDebugLog("Switching to direct canvas rendering mode");
      initializeDirectCanvas();
    }
  }, [useDirectRender]);

  return (
    <div className="container mx-auto p-6">
      <div className="flex justify-between items-center mb-6">
        <div className="flex items-center space-x-4">
          <Label>Template Name:</Label>
          <Input 
            value={name} 
            onChange={(e) => setName(e.target.value)} 
            className="max-w-xs"
          />
        </div>
        <div className="flex space-x-2">
          <Button variant="outline" onClick={handleSaveTemplate}>
            Save
          </Button>
          <Button variant="outline" onClick={handleExportAsPDF}>
            Export PDF
          </Button>
          <Button variant="outline" onClick={handleExportAsPNG}>
            Export PNG
          </Button>
        </div>
      </div>
      
      {error && (
        <Alert variant="destructive" className="mb-4">
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-12 gap-4">
        <div className="col-span-9">
          <div className="bg-white p-4 border rounded-md shadow-sm">
            <div className="flex justify-between items-center mb-3">
              <div className="flex items-center space-x-2">
                <Label>Zoom:</Label>
                <SimpleSlider
                  value={zoomLevel}
                  min={25}
                  max={200}
                  step={5}
                  className="w-32"
                  id="zoom-slider"
                  onChange={handleZoomChange}
                />
                <span className="text-sm">{zoomLevel}%</span>
              </div>
              <div className="flex items-center space-x-4">
                <div className="flex items-center space-x-2">
                  <SimpleToggle 
                    id="show-grid" 
                    checked={showGrid} 
                    onCheckedChange={setShowGrid}
                    label="Grid"
                  />
                </div>
                
                <div className="flex items-center space-x-2">
                  <SimpleToggle
                    id="direct-render" 
                    checked={useDirectRender} 
                    onCheckedChange={setUseDirectRender}
                    label="Direct Render"
                  />
                </div>
                
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button 
                        variant="ghost" 
                        size="icon" 
                        onClick={bringElementForward}
                        disabled={!selectedElement}
                      >
                        <ArrowUpIcon className="h-4 w-4" />
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>Bring Forward</TooltipContent>
                  </Tooltip>
                </TooltipProvider>
                
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button 
                        variant="ghost" 
                        size="icon" 
                        onClick={sendElementBackward}
                        disabled={!selectedElement}
                      >
                        <ArrowDownIcon className="h-4 w-4" />
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>Send Backward</TooltipContent>
                  </Tooltip>
                </TooltipProvider>
                
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button 
                        variant="ghost" 
                        size="icon" 
                        onClick={duplicateSelectedElement}
                        disabled={!selectedElement}
                      >
                        <CopyIcon className="h-4 w-4" />
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>Duplicate</TooltipContent>
                  </Tooltip>
                </TooltipProvider>
                
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button 
                        variant="ghost" 
                        size="icon" 
                        onClick={deleteSelectedElement}
                        disabled={!selectedElement}
                      >
                        <TrashIcon className="h-4 w-4" />
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>Delete</TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
            </div>
            
            <div className="flex justify-center">
              {!useDirectRender ? (
                <div style={{ 
                  transform: `scale(${zoomLevel / 100})`, 
                  transformOrigin: 'top center',
                  transition: 'transform 0.2s ease'
                }}>
                  <SimpleCanvas 
                    width={A4_WIDTH} 
                    height={A4_HEIGHT}
                    onReady={handleCanvasReady}
                    background="#ffffff"
                    showGrid={showGrid}
                  />
                </div>
              ) : (
                <div 
                  ref={canvasContainerRef}
                  className="direct-canvas-container" 
                  style={{ 
                    width: `${A4_WIDTH}px`, 
                    height: `${A4_HEIGHT}px`,
                    position: 'relative',
                    backgroundColor: '#ffffff',
                    border: '1px solid #ccc',
                    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',
                    transformOrigin: 'top left',
                    transition: 'transform 0.2s ease'
                  }}
                >
                  <canvas 
                    ref={canvasRef}
                    id="direct-canvas" 
                    width={A4_WIDTH} 
                    height={A4_HEIGHT}
                    style={{
                      position: 'absolute',
                      top: 0,
                      left: 0,
                      width: `${A4_WIDTH}px`,
                      height: `${A4_HEIGHT}px`
                    }}
                  />
                </div>
              )}
            </div>
          </div>
        </div>
        
        <div className="col-span-3">
          <Tabs defaultValue="elements" value={activeTab} onValueChange={setActiveTab}>
            <TabsList className="grid grid-cols-3 mb-4">
              <TabsTrigger value="elements">Elements</TabsTrigger>
              <TabsTrigger value="placeholders">Placeholders</TabsTrigger>
              <TabsTrigger value="properties">Properties</TabsTrigger>
            </TabsList>
            
            <TabsContent value="elements" className="bg-white p-4 border rounded-md shadow-sm">
              <h2 className="text-lg font-semibold mb-3">Elements</h2>
              <div className="space-y-2">
                <Button variant="outline" className="w-full justify-start" onClick={handleAddText}>
                  Add Text
                </Button>
                
                <Button variant="outline" className="w-full justify-start" onClick={handleAddRectangle}>
                  Add Rectangle
                </Button>
                
                <Button variant="outline" className="w-full justify-start" onClick={() => {
                  if (fabricCanvas.current && fabricLib.current) {
                    try {
                      // Add circle with enhanced visibility
                      const circle = new fabricLib.current.Circle({
                        left: 50 + Math.random() * 200,
                        top: 50 + Math.random() * 200,
                        radius: 40,
                        fill: '#e6f7ff',
                        stroke: '#0066cc',
                        strokeWidth: 2,
                        selectable: true,
                        evented: true,
                        visible: true,
                        opacity: 1
                      });
                      
                      // Clear selection
                      fabricCanvas.current.discardActiveObject();
                      
                      // Add element
                      fabricCanvas.current.add(circle);
                      
                      // Set as active
                      fabricCanvas.current.setActiveObject(circle);
                      
                      // Force render
                      safeRenderAll(fabricCanvas.current);
                      
                      // Log
                      addDebugLog("Added circle element");
                      
                      // Feedback
                      toast.success("Circle added to canvas");
                    } catch (err) {
                      console.error("Error adding circle:", err);
                      addDebugLog(`Error adding circle: ${err.message}`);
                      toast.error("Failed to add circle: " + err.message);
                    }
                  } else {
                    toast.error("Canvas is not ready");
                  }
                }}>
                  Add Circle
                </Button>
                
                <Button variant="outline" className="w-full justify-start" onClick={() => {
                  if (fabricCanvas.current && fabricLib.current) {
                    try {
                      // Add line with enhanced visibility
                      const line = new fabricLib.current.Line([50, 50, 200, 50], {
                        left: 50 + Math.random() * 200,
                        top: 50 + Math.random() * 200,
                        stroke: '#000000',
                        strokeWidth: 3,
                        selectable: true,
                        evented: true,
                        visible: true,
                        opacity: 1
                      });
                      
                      // Clear selection
                      fabricCanvas.current.discardActiveObject();
                      
                      // Add and setup
                      fabricCanvas.current.add(line);
                      fabricCanvas.current.setActiveObject(line);
                      
                      // Force render
                      safeRenderAll(fabricCanvas.current);
                      
                      // Log
                      addDebugLog("Added line element");
                      
                      // Feedback
                      toast.success("Line added to canvas");
                    } catch (err) {
                      console.error("Error adding line:", err);
                      addDebugLog(`Error adding line: ${err.message}`);
                      toast.error("Failed to add line: " + err.message);
                    }
                  } else {
                    toast.error("Canvas is not ready");
                  }
                }}>
                  Add Line
                </Button>
                
                <Button variant="outline" className="w-full justify-start" onClick={() => {
                  // Image would normally be uploaded or chosen from library
                  toast.info("Image upload functionality to be implemented");
                }}>
                  Add Image
                </Button>
              </div>
              
              {selectedElement && (
                <div className="mt-4 pt-4 border-t border-gray-200">
                  <h3 className="text-sm font-semibold mb-2">Element Actions</h3>
                  <div className="flex flex-wrap gap-2">
                    <Button size="sm" variant="outline" onClick={bringElementForward}>
                      <ChevronUp className="h-4 w-4 mr-1" />
                      Forward
                    </Button>
                    <Button size="sm" variant="outline" onClick={sendElementBackward}>
                      <ChevronDown className="h-4 w-4 mr-1" />
                      Backward
                    </Button>
                    <Button size="sm" variant="outline" onClick={duplicateSelectedElement}>
                      <Copy className="h-4 w-4 mr-1" />
                      Duplicate
                    </Button>
                    <Button 
                      size="sm" 
                      variant="destructive" 
                      onClick={() => {
                        setElementToDelete(selectedElement);
                        setShowConfirmDelete(true);
                      }}
                    >
                      <Trash className="h-4 w-4 mr-1" />
                      Delete
                    </Button>
                  </div>
                </div>
              )}
            </TabsContent>
            
            <TabsContent value="placeholders" className="bg-white p-4 border rounded-md shadow-sm">
              <h2 className="text-lg font-semibold mb-3">Placeholders</h2>
              <p className="text-sm text-gray-600 mb-4">
                Add placeholders to your template. These will be filled with real data when creating an affidavit.
              </p>
              
              <div className="max-h-[400px] overflow-y-auto pr-2">
                {placeholders.map((placeholder) => (
                  <div 
                    key={placeholder.id} 
                    className="p-2 mb-2 border border-gray-200 rounded-md hover:bg-gray-50 cursor-pointer"
                    onClick={() => addPlaceholderToCanvas(placeholder)}
                  >
                    <div className="font-medium">{placeholder.name}</div>
                    {placeholder.description && (
                      <div className="text-xs text-gray-500">{placeholder.description}</div>
                    )}
                    <div className="text-xs text-gray-400">Type: {placeholder.type}</div>
                  </div>
                ))}
              </div>
              
              <div className="mt-4 pt-4 border-t border-gray-200">
                <h3 className="text-sm font-semibold mb-2">Add Custom Placeholder</h3>
                <div className="flex items-center space-x-2">
                  <Input 
                    placeholder="Placeholder name" 
                    className="flex-1"
                    onKeyDown={(e) => {
                      if (e.key === 'Enter') {
                        createCustomPlaceholder((e.target as HTMLInputElement).value);
                        (e.target as HTMLInputElement).value = '';
                      }
                    }}
                  />
                  <Button 
                    variant="outline"
                    onClick={() => {
                      const input = document.querySelector('input[placeholder="Placeholder name"]') as HTMLInputElement;
                      if (input && input.value) {
                        createCustomPlaceholder(input.value);
                        input.value = '';
                      }
                    }}
                  >
                    <Plus className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            </TabsContent>
            
            <TabsContent value="properties" className="bg-white p-4 border rounded-md shadow-sm">
              <h2 className="text-lg font-semibold mb-3">Properties</h2>
              
              {selectedElement ? (
                <div className="space-y-4">
                  {selectedElement.type === 'textbox' || selectedElement.type === 'text' ? (
                    <>
                      <div>
                        <Label htmlFor="text-content" className="text-sm">Text Content</Label>
                        <Input
                          id="text-content"
                          value={selectedElement.text || ''}
                          onChange={(e) => updateSelectedElementProperty('text', e.target.value)}
                        />
                      </div>
                      
                      <div>
                        <Label htmlFor="font-family" className="text-sm">Font Family</Label>
                        <Select
                          value={selectedElement.fontFamily || 'Arial'}
                          onValueChange={(value) => updateSelectedElementProperty('fontFamily', value)}
                        >
                          <SelectTrigger id="font-family">
                            <SelectValue placeholder="Select font" />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="Arial">Arial</SelectItem>
                            <SelectItem value="Times New Roman">Times New Roman</SelectItem>
                            <SelectItem value="Courier New">Courier New</SelectItem>
                            <SelectItem value="Georgia">Georgia</SelectItem>
                            <SelectItem value="Verdana">Verdana</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>
                      
                      <div>
                        <Label htmlFor="font-size" className="text-sm">Font Size</Label>
                        <div className="flex items-center space-x-2">
                          <SimpleSlider
                            value={selectedElement ? (selectedElement.fontSize || 16) : 16}
                            min={8}
                            max={72}
                            step={1}
                            className="flex-1"
                            id="font-size"
                            onChange={(value) => updateSelectedElementProperty('fontSize', value)}
                          />
                          <span className="w-8 text-center">{selectedElement?.fontSize || 16}</span>
                        </div>
                      </div>
                      
                      <div>
                        <Label htmlFor="text-color" className="text-sm">Text Color</Label>
                        <div className="flex items-center space-x-2">
                          <Input
                            id="text-color"
                            type="color"
                            value={selectedElement.fill || '#000000'}
                            onChange={(e) => updateSelectedElementProperty('fill', e.target.value)}
                            className="w-12 h-8 p-0"
                          />
                          <Input
                            value={selectedElement.fill || '#000000'}
                            onChange={(e) => updateSelectedElementProperty('fill', e.target.value)}
                            className="flex-1"
                          />
                        </div>
                      </div>
                    </>
                  ) : (
                    <div className="space-y-4">
                      <div>
                        <Label htmlFor="shape-fill" className="text-sm">Fill Color</Label>
                        <div className="flex items-center space-x-2">
                          <Input
                            id="shape-fill"
                            type="color"
                            value={selectedElement.fill || '#f0f0f0'}
                            onChange={(e) => updateSelectedElementProperty('fill', e.target.value)}
                            className="w-12 h-8 p-0"
                          />
                          <Input
                            value={selectedElement.fill || '#f0f0f0'}
                            onChange={(e) => updateSelectedElementProperty('fill', e.target.value)}
                            className="flex-1"
                          />
                        </div>
                      </div>
                      
                      <div>
                        <Label htmlFor="stroke-color" className="text-sm">Border Color</Label>
                        <div className="flex items-center space-x-2">
                          <Input
                            id="stroke-color"
                            type="color"
                            value={selectedElement.stroke || '#000000'}
                            onChange={(e) => updateSelectedElementProperty('stroke', e.target.value)}
                            className="w-12 h-8 p-0"
                          />
                          <Input
                            value={selectedElement.stroke || '#000000'}
                            onChange={(e) => updateSelectedElementProperty('stroke', e.target.value)}
                            className="flex-1"
                          />
                        </div>
                      </div>
                      
                      <div>
                        <Label htmlFor="stroke-width" className="text-sm">Border Width</Label>
                        <div className="flex items-center space-x-2">
                          <SimpleSlider
                            value={selectedElement ? (selectedElement.strokeWidth || 1) : 1}
                            min={0}
                            max={20}
                            step={1}
                            className="flex-1"
                            id="stroke-width"
                            onChange={(value) => updateSelectedElementProperty('strokeWidth', value)}
                          />
                          <span className="w-8 text-center">{selectedElement?.strokeWidth || 1}</span>
                        </div>
                      </div>
                    </div>
                  )}
                  
                  <div className="pt-4 border-t border-gray-200">
                    <h3 className="text-sm font-semibold mb-2">Position & Size</h3>
                    <div className="grid grid-cols-2 gap-2">
                      <div>
                        <Label htmlFor="left-pos" className="text-xs">X Position</Label>
                        <Input
                          id="left-pos"
                          type="number"
                          value={Math.round(selectedElement.left) || 0}
                          onChange={(e) => updateSelectedElementProperty('left', Number(e.target.value))}
                        />
                      </div>
                      <div>
                        <Label htmlFor="top-pos" className="text-xs">Y Position</Label>
                        <Input
                          id="top-pos"
                          type="number"
                          value={Math.round(selectedElement.top) || 0}
                          onChange={(e) => updateSelectedElementProperty('top', Number(e.target.value))}
                        />
                      </div>
                      
                      {selectedElement.width !== undefined && (
                        <div>
                          <Label htmlFor="width" className="text-xs">Width</Label>
                          <Input
                            id="width"
                            type="number"
                            value={Math.round(selectedElement.width) || 0}
                            onChange={(e) => updateSelectedElementProperty('width', Number(e.target.value))}
                          />
                        </div>
                      )}
                      
                      {selectedElement.height !== undefined && (
                        <div>
                          <Label htmlFor="height" className="text-xs">Height</Label>
                          <Input
                            id="height"
                            type="number"
                            value={Math.round(selectedElement.height) || 0}
                            onChange={(e) => updateSelectedElementProperty('height', Number(e.target.value))}
                          />
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              ) : (
                <div className="text-center py-4 text-gray-500">
                  Select an element to edit its properties
                </div>
              )}
            </TabsContent>
          </Tabs>
          
          {/* Debug Panel */}
          <Card className="mt-4">
            <CardHeader>
              <CardTitle className="flex justify-between items-center">
                <span>Debug Panel</span>
                <div className="flex space-x-2">
                  <Button 
                    size="sm"
                    variant="outline" 
                    onClick={() => {
                      setDebugInfo([]);
                      addDebugLog("Debug log cleared");
                    }}
                  >
                    Clear Log
                  </Button>
                </div>
              </CardTitle>
            </CardHeader>
            <CardContent className="p-2">
              <div className="bg-gray-900 text-green-400 p-3 rounded font-mono text-xs overflow-auto max-h-80">
                {debugInfo.map((log, i) => (
                  <div key={i}>{log}</div>
                ))}
              </div>
              
              <div className="flex space-x-2 mt-3">
                <Button 
                  size="sm"
                  variant="outline" 
                  onClick={() => {
                    if (fabricCanvas.current) {
                      try {
                        addDebugLog("DIAGNOSTICS: Running canvas diagnostics");
                        
                        // Basic info
                        addDebugLog(`Canvas dimensions: ${fabricCanvas.current.width}x${fabricCanvas.current.height}`);
                        
                        // Context check
                        const hasContext = fabricCanvas.current.contextContainer !== null;
                        addDebugLog(`Canvas context: ${hasContext ? 'AVAILABLE' : 'NULL'}`);
                        
                        // Lower canvas check
                        const hasLowerCanvas = fabricCanvas.current.lowerCanvasEl !== null;
                        addDebugLog(`Lower canvas element: ${hasLowerCanvas ? 'EXISTS' : 'MISSING'}`);
                        
                        // Objects
                        const objects = fabricCanvas.current.getObjects();
                        addDebugLog(`Object count: ${objects.length}`);
                        
                        // DOM structure
                        if (fabricCanvas.current.wrapperEl) {
                          const wrapperChildren = fabricCanvas.current.wrapperEl.childNodes.length;
                          addDebugLog(`Canvas wrapper children: ${wrapperChildren}`);
                        } else {
                          addDebugLog(`Canvas wrapper: MISSING`);
                        }
                        
                        // Log object details
                        logCanvasObjects(fabricCanvas.current);
                        
                        // Check for styling issues
                        if (fabricCanvas.current.wrapperEl) {
                          const style = window.getComputedStyle(fabricCanvas.current.wrapperEl);
                          addDebugLog(`Canvas visibility: ${style.visibility}, display: ${style.display}, opacity: ${style.opacity}`);
                          
                          // Check if wrapper is in viewport
                          const rect = fabricCanvas.current.wrapperEl.getBoundingClientRect();
                          const isVisible = 
                            rect.top < window.innerHeight &&
                            rect.bottom > 0 &&
                            rect.left < window.innerWidth &&
                            rect.right > 0;
                          addDebugLog(`Canvas in viewport: ${isVisible ? 'YES' : 'NO'}`);
                          addDebugLog(`Canvas position: top=${rect.top}, left=${rect.left}, width=${rect.width}, height=${rect.height}`);
                        }
                        
                        // Check if canvas is rendering to screen
                        if (fabricCanvas.current.lowerCanvasEl) {
                          try {
                            const ctx = fabricCanvas.current.lowerCanvasEl.getContext('2d');
                            if (ctx) {
                              // Sample a few points
                              const midX = fabricCanvas.current.width / 2;
                              const midY = fabricCanvas.current.height / 2;
                              const samples = [
                                {x: 10, y: 10},
                                {x: midX, y: midY},
                                {x: fabricCanvas.current.width - 10, y: fabricCanvas.current.height - 10}
                              ];
                              
                              samples.forEach((point, i) => {
                                try {
                                  const pixel = ctx.getImageData(point.x, point.y, 1, 1).data;
                                  addDebugLog(`Pixel sample ${i+1} (${point.x},${point.y}): rgba(${pixel[0]},${pixel[1]},${pixel[2]},${pixel[3]})`);
                                } catch (e) {
                                  addDebugLog(`Error sampling pixel ${i+1}: ${e}`);
                                }
                              });
                            } else {
                              addDebugLog(`Cannot get 2D context from canvas element`);
                            }
                          } catch (err) {
                            addDebugLog(`Error analyzing canvas: ${err}`);
                          }
                        }
                        
                        // Attempt to fix any detected issues
                        addDebugLog("DIAGNOSTICS: Attempting repair operations");
                        
                        // Force canvas redraw
                        safeRenderAll(fabricCanvas.current);
                        
                        // Try to ensure canvas is properly styled
                        if (fabricCanvas.current.wrapperEl) {
                          fabricCanvas.current.wrapperEl.style.visibility = 'visible';
                          fabricCanvas.current.wrapperEl.style.display = 'block';
                          fabricCanvas.current.wrapperEl.style.opacity = '1';
                          addDebugLog("Fixed wrapper element styling");
                        }
                        
                        // Ensure all objects are visible
                        objects.forEach((obj, i) => {
                          obj.set({
                            visible: true,
                            opacity: 1
                          });
                          addDebugLog(`Made object ${i} visible`);
                        });
                        
                        // Final render
                        safeRenderAll(fabricCanvas.current);
                        addDebugLog("DIAGNOSTICS: Repair operations completed");
                        
                      } catch (err) {
                        addDebugLog(`Diagnostics error: ${err}`);
                      }
                    } else {
                      addDebugLog("No canvas available for diagnostics");
                    }
                  }}
                >
                  Run Diagnostics
                </Button>
                
                <Button
                  size="sm"
                  variant="default"
                  onClick={() => {
                    if (fabricCanvas.current && fabricLib.current) {
                      try {
                        // Force test element with extreme visibility
                        const testCircle = new fabricLib.current.Circle({
                          radius: 50,
                          fill: 'red',
                          stroke: 'black',
                          strokeWidth: 5,
                          left: 200,
                          top: 200,
                          opacity: 1,
                          visible: true,
                          selectable: true,
                          evented: true
                        });
                        
                        fabricCanvas.current.discardActiveObject();
                        fabricCanvas.current.add(testCircle);
                        fabricCanvas.current.setActiveObject(testCircle);
                        
                        // Multiple renders to ensure it shows
                        safeRenderAll(fabricCanvas.current);
                        
                        // Force a redraw after a delay
                        setTimeout(() => {
                          safeRenderAll(fabricCanvas.current);
                          
                          // Check canvas rendering
                          logCanvasObjects(fabricCanvas.current);
                          
                          // Try to force element to front
                          testCircle.bringToFront();
                          safeRenderAll(fabricCanvas.current);
                          
                          addDebugLog("Emergency test element added and rendered");
                        }, 300);
                        
                      } catch (err) {
                        addDebugLog(`Error adding test element: ${err}`);
                      }
                    } else {
                      addDebugLog("Canvas not ready for test element");
                    }
                  }}
                >
                  Add Test Element
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
      
      {/* Confirmation Dialog for Element Deletion */}
      <AlertDialog open={showConfirmDelete} onOpenChange={setShowConfirmDelete}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Element</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete this element? This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={deleteSelectedElement}>Delete</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
} 